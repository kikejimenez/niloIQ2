# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/02_national/04_TimeSeries/04_SubSeasonal.ipynb.

# %% auto 0
__all__ = ['subseasonal_avg', 'plot_subseasonal_two_years', 'plot', 'years_2013_and_2014_comparison']

# %% ../../nbs/02_national/04_TimeSeries/04_SubSeasonal.ipynb 2
from national.data_preprocessing.date_features import Data
from national.time_series import process

import plotly.graph_objects as go
import numpy as np
import pandas as pd

from IPython.display import display, Markdown

from plotly.subplots import make_subplots

from national.util import constants

# %% ../../nbs/02_national/04_TimeSeries/04_SubSeasonal.ipynb 3
def subseasonal_avg(ts=pd.Series,):
    """
    Takes the average of over samples grouped by 
    montly subseason
    """

    return ts.groupby(lambda x: x.month).transform(np.mean)

# %% ../../nbs/02_national/04_TimeSeries/04_SubSeasonal.ipynb 5
def plot_subseasonal_two_years(
    ts: pd.Series,
    kpi: str = None,
    ylog: bool = False,
) -> make_subplots:
    """
    Given a time series it decompose it and plot the actual values, the trend, the residuals
    and the seasonal component. By default, it uses additive models
    
    :param time_series: A pandas dataframe with time series structure
    :param model: An indicator if the model is additive or multiplicative. Default 'Additive'
    :return: A subplot object with the time series decomposition.
    """
    fig = go.Figure()

    years = [2020, 2021]
    colors = [["#83cee0", "#e94822"], ["#5e87b8", "#f2910a"]]

    months = ts.index.month.value_counts().index.sort_values().values
    for color, year in zip(colors, years):
        year_ts = ts[ts.index.year == year]

        year_ts.index = year_ts.index + pd.to_timedelta(
            (2014 - year) * 365, unit='days')

        sub_ts = subseasonal_avg(year_ts)

        fig.add_trace(
            go.Scatter(
                name=f"Net {kpi} ({year})",
                x=year_ts.index,
                y=year_ts[kpi],
                marker_color=color[0],
                hovertemplate="Date: %{x} <br>" + "Net Value: $ %{y}",
                showlegend=True,
            ),)

        for month in months:

            month_ts = sub_ts[kpi].where(sub_ts.index.month == month)
            fig.add_trace(
                go.Scatter(
                    name=f"Monthly Average ({year})",
                    x=month_ts.index,
                    y=month_ts.values.round(2),
                    hovertemplate="Date: %{x} <br>" + "Net Value: $ %{y}",
                    marker_color=color[1],
                    showlegend=int(month) == 12,
                ),)

    if ylog:
        fig.update_yaxes(type="log",)

    title_text = f"Net {kpi} for Years {years[0]} and {years[1]} with Monthly Average"

    fig.update_layout(
        height=500,
        autosize=True,
        title_text=title_text,
        xaxis=dict(
            tickformat='%b',
            dtick=86400000.0 * 30,
        ),        
        template=constants.PLOTLY_THEME,
        )

    return fig

# %% ../../nbs/02_national/04_TimeSeries/04_SubSeasonal.ipynb 6
def plot(
    df: pd.DataFrame,
    kpi: str,
    freqs: list,
    ylog: bool = False,
):

    agg_method = {
        kpi: np.sum,
    }
    
    
    
    ts = process.time_series(
        df=df,
        time_column='date',
        freq=freqs,
        agg_method=agg_method,
    )
    

    ts = ts[ts[kpi] > 0] 
    
    
    fig = plot_subseasonal_two_years(
        ts=ts,
        kpi=kpi,
    )

    return fig

# %% ../../nbs/02_national/04_TimeSeries/04_SubSeasonal.ipynb 9
def years_2013_and_2014_comparison(
    df: pd.DataFrame,
    kpi: str,
    freqs: list = ['W-Fri', 'Q'],
    ylog: bool = False,
) -> str:

    months = {
        1: "January",
        2: "February",
        3: "March",
        4: "April",
        5: "May",
        6: "June",
        7: "July",
        8: "August",
        9: "September",
        10: "October",
        11: "November",
        12: "December",
    }

    agg_method = {
        kpi: np.sum,
    }
    years = [2020,2021]

    ts = process.time_series(
        df=df,
        time_column='date',
        freq=freqs,
        agg_method=agg_method,
    )

    ts = ts[ts[kpi] > 0]

    ts3 = ts[ts.index.year == years[0]]
    ts4 = ts[ts.index.year == years[1]]

    sub_ts3 = subseasonal_avg(ts3)
    sub_ts4 = subseasonal_avg(ts4)
    

    is_2013_higher = np.array([
        max(sub_ts3[sub_ts3.index.month == month][kpi]) > max(
            sub_ts4[sub_ts4.index.month == month][kpi]) for month in months.keys()
    ])



    counts_2013 = sum(is_2013_higher)

    if counts_2013 == 6:
        text = f"2014 and 2013 have the same number months with higher {kpi} averages"
    else:

        years = [2013, 2014] if counts_2013 > 6 else years
        
        value_picker = ~is_2013_higher if counts_2013 > 6 else is_2013_higher

        higher_list = np.array([x for x in months.values()])[value_picker]

        higher = ', '.join(higher_list[:-1]) + ' and ' + higher_list[-1]

        text = f"""
        The year {years[0]} has more months with higher {kpi} averages than the year of {years[1]}.
        
        The months of {years[1]} that have a higher {kpi} averaged are {higher}
        """

    markdown_str = f"""
***{kpi} in years 2013 and 2014.*** \n\n
""" + text

    return display(Markdown(markdown_str))
