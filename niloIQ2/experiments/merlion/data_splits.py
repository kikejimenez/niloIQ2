# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/02_national/05_Experiments/99_merlion/01_DataSplits.ipynb.

# %% auto 0
__all__ = ['threshold_mask', 'vis_train_test_split', 'plot', 'TimeStamps', 'Data']

# %% ../../../nbs/02_national/05_Experiments/99_merlion/01_DataSplits.ipynb 3
from datetime import datetime
from typing import Tuple
import numpy as np
import pandas as pd
import plotly.graph_objects as go

from merlion.utils import TimeSeries
from national.data_preprocessing import date_features
from national.time_series.process import time_series as gen_time_series

from national.util import constants
from national import tables

from national.experiments.merlion.future_timestamps import Data as FuturisticData


# %% ../../../nbs/02_national/05_Experiments/99_merlion/01_DataSplits.ipynb 4
def threshold_mask(
    ts: pd.Series,
    threshold: float,
) -> pd.Series:
    """
    Returns a numpy array with boolean values depending
    on whether the fraction position/total_size is less than the threshold.
    """
   
    if threshold == 1:
        threshold_f = lambda x: True
    else:
        threshold_f = lambda x: (x + 1) / len(ts) < threshold

    return pd.Series(
        ts.reset_index().index.map(threshold_f),
        index=ts.index,
    ).astype(bool)

# %% ../../../nbs/02_national/05_Experiments/99_merlion/01_DataSplits.ipynb 5
def vis_train_test_split(
    ts: pd.Series,
    kpi: str,
    train_mask: pd.Series,
):
    fig = go.Figure()

    fig.add_trace(
        go.Scatter(
            x=ts.index,
            y=ts[kpi],
            marker_color='cornflowerblue',
        ),)

    val = ts[~train_mask]

    x0 = val.head(1).index[0]
    x1 = val.tail(1).index[0]

    # Add shape regions
    fig.add_vrect(
        x0=x0,
        x1=x1,
        fillcolor="LightSalmon",
        opacity=0.3,
        layer="below",
        line_width=0,
    )

    title_text = f"Train - Validation Split for {kpi}"

    fig.update_layout(
        height=500,
        autosize=True,
        title_text=title_text,
        template=constants.PLOTLY_THEME,
    )

    return fig

# %% ../../../nbs/02_national/05_Experiments/99_merlion/01_DataSplits.ipynb 6
def _preprocess_labeled(
    df: pd.DataFrame,
    kpi: str,
    freq: str,
    threshold,
):
    mask = df[kpi] > 0
    ts = gen_time_series(
        df=df[mask],
        time_column='date',
        freq=freq,
        agg_method={kpi:np.mean},
    )

    ts.dropna(inplace=True)

    train_mask = threshold_mask(
        ts[kpi],
        threshold=threshold,
    )

    return ts, train_mask

# %% ../../../nbs/02_national/05_Experiments/99_merlion/01_DataSplits.ipynb 7
def _preprocess_unlabeled(
    df: pd.DataFrame,
    freq: str,
) -> TimeSeries:

    ts = df.copy()
    ts.set_index(
        'date',
        inplace=True,
    )
    ts.dropna(inplace=True)

    return TimeSeries.from_pd(ts)

# %% ../../../nbs/02_national/05_Experiments/99_merlion/01_DataSplits.ipynb 8
def plot(
    df: pd.DataFrame,
    kpi: str,
    freq: str,
    threshold: float = 0.8,
):

    ts, train_mask = _preprocess_labeled(
        df=df,
        kpi=kpi,
        freq=freq,
        threshold=threshold,
    )

    fig = vis_train_test_split(ts, kpi, train_mask=train_mask)

    return fig

# %% ../../../nbs/02_national/05_Experiments/99_merlion/01_DataSplits.ipynb 9
def _split(
    df: pd.DataFrame,
    kpi: str,
    freq: str,
    threshold: float,
) -> Tuple[TimeSeries, TimeSeries]:
    ts, train_mask = _preprocess_labeled(
        df=df,
        kpi=kpi,
        freq=freq,
        threshold=threshold,
    )

    train_data = TimeSeries.from_pd(ts[train_mask])
    val_data = TimeSeries.from_pd(ts[~train_mask])

    return ts, train_mask, train_data, val_data

# %% ../../../nbs/02_national/05_Experiments/99_merlion/01_DataSplits.ipynb 10
def _prepare_test_set(
    kpi: str,
    freq: str,
    data_path,
) -> TimeSeries:

    if data_path is None:
        return TimeSeries.from_pd(pd.DataFrame({'date': []}))

    test = pd.read_csv(data_path)
    
    if kpi in test.columns:
        ts, _ = _preprocess_labeled(
            df=test,
            kpi=kpi,
            freq=freq,
            threshold=1,
        )

    else:
        ts = _preprocess_unlabeled(df=test, freq=freq)
        
    return ts

# %% ../../../nbs/02_national/05_Experiments/99_merlion/01_DataSplits.ipynb 11
class TimeStamps:

    def __init__(self):
        self.val = None
        self.test = None
        self.train = None
        self.future = None

# %% ../../../nbs/02_national/05_Experiments/99_merlion/01_DataSplits.ipynb 12
class Data(FuturisticData):

    def __init__(
        self,
        kpi: str,
        freq: str,
        df: pd.DataFrame,
        test_path: str = None,
        # test_frac: float = 0.15,
        val_frac: float = 0.15,
        periods: str = None,
        **args,
    ):

        super().__init__()

        (
            self.time_series,
            self.train_mask,
            self.train,
            self.val,
        ) = _split(
            df=df,
            kpi=kpi,
            freq=freq,
            threshold=1. - val_frac if val_frac > 0 else 1,
        )

        self.test = _prepare_test_set(
            kpi=kpi,
            freq=freq,
            data_path=test_path,
        )

        self.kpi = kpi
        self.freq = freq
        self.periods = periods

        self._gen_futuristic_set()

        self.time_stamps = TimeStamps()

    def _gen_futuristic_set(self):

        _dates = None
        if len(self.test) > 0:
            _dates = self.test
        elif len(self.val) > 0:
            _dates = self.val
        elif len(self.train) > 0:
            _dates = self.train
     
        if _dates is not None:
                
            self.futuristic_start_date = self._utc_to_string(max(_dates)[0])
            self.gen_futuristic_time_stamps()

    def _utc_to_string(self, x):
        return datetime.utcfromtimestamp(x).strftime('%Y-%m-%d')
