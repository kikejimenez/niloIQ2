# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/02_national/05_Experiments/99_merlion/98_ForecastMetrics.ipynb.

# %% auto 0
__all__ = ['ForecastScoreAccumulator']

# %% ../../../nbs/02_national/05_Experiments/99_merlion/98_ForecastMetrics.ipynb 2
import sys
import logging
import numpy as np

from merlion.evaluate.forecast import ForecastScoreAccumulator as MerlionForecastScoreAccumulator

# %% ../../../nbs/02_national/05_Experiments/99_merlion/98_ForecastMetrics.ipynb 3
logging.disable(sys.maxsize)

# %% ../../../nbs/02_national/05_Experiments/99_merlion/98_ForecastMetrics.ipynb 4
def _mean_squared_error(
    *,
    ts: np.array,
    f: np.array,
) -> float:
    """
    Computes the mean squared error:

    $$(1/n)\sum^{n}_{i} | ts[i] - f[i]|**2, n = len(ts) = len(f)$$

    .Ignores nan values in times-series or the forecast.

    ------
    Parameters
    ------

    ts : np.array with the time-series
    f :  np.array with the forecast

    -------
    Returns
    -------
    
    """
    d = (ts - f)**2
    w = ~np.isnan(d)
    n = len(d[w])

    return np.divide(
        np.sum(d, where=w),
        n,
        where=n > 0,
    )

# %% ../../../nbs/02_national/05_Experiments/99_merlion/98_ForecastMetrics.ipynb 5
def _relative_root_mean_square_error(
    *,
    ts: np.array,
    f: np.array,
) -> float:
    """
    Computes the root mean square error:

    $$ \sqrt((1/n)\sum^{n}_{i}(ts[i] - f[i])**2) / ((1/n) \sum^{n}_{i} ts[i] ) ,  n = len(ts) = len(f)$$

    .Ignores nan values in times-series or the forecast.

    ------
    Parameters
    ------

    ts : np.array with the time-series
    f :  np.array with the forecast

    -------
    Returns
    -------
    
    """

    mean = np.mean(ts)
    return np.divide(np.sqrt(_mean_squared_error(ts=ts, f=f)),mean, where=mean!=0)

# %% ../../../nbs/02_national/05_Experiments/99_merlion/98_ForecastMetrics.ipynb 7
def _root_mean_square_percentage_error(
    *,
    ts: np.array,
    f: np.array,
) -> float:
    """
    Computes the mean absolute percentage error:

    $$ \sqrt{ (1/n) \sum  ( (ts[i] - f[i])  /ts[i] ) ^ 2 },  n* = len(ts) = len(f)$$

    .Ignores nan values and division by zero.
    n is n* minus the ignored values

    ------
    Parameters
    ------

    ts : np.array with the time-series
    f :  np.array with the forecast

    -------
    Returns
    -------
    
    """

    pe = np.divide(ts - f, ts, where=ts != 0)[ts != 0]
    
    w = ~np.isnan(pe)

    n = len(pe[w])

    return np.sqrt(np.divide(
        np.sum(np.square(pe, where=w)),
        n,
        where=n > 0,
    ))

# %% ../../../nbs/02_national/05_Experiments/99_merlion/98_ForecastMetrics.ipynb 12
class ForecastScoreAccumulator(MerlionForecastScoreAccumulator):
    
    def rmspe(self):
        """
        Root Mean Square Percentage Error (RMSPE)

        For ground truth time series $ts$ and predicted time series $f$
        of length $n*$, it is computed as

        $$ \sqrt{ (1/n) \sum  ( (ts[i] - f[i])  / ts[i] ) ^ 2 } $$

        Ignores nan values and division by zero.
        n is n* minus the ignored values
        """
        self.check_before_eval()
        predict_values = self.predict.univariates[
            self.predict.names[0]].np_values
        ground_truth_values = self.ground_truth.univariates[
            self.ground_truth.names[0]].np_values
        

        return _root_mean_square_percentage_error(
            ts=ground_truth_values,
            f=predict_values,
        )
    
    def rrmse(self):
        """
        Relative Root Mean Square Error (RRMSE)

        For ground truth time series $ts$ and predicted time series $f$
        of length $n*$, it is computed as

        $$  RMSE / Mean $$
        
        where 
        $$ RMSE =  \sqrt((1/n)\sum^{n}_{i}(ts[i] - f[i])**2) $$ 
        and
        $$ ((1/n) \sum^{n}_{i} ts[i] ) $$
        

        Ignores nan values and division by zero.
        n is n* minus the ignored values
        """
        self.check_before_eval()
        predict_values = self.predict.univariates[
            self.predict.names[0]].np_values
        ground_truth_values = self.ground_truth.univariates[
            self.ground_truth.names[0]].np_values
        

        return _relative_root_mean_square_error(
            ts=ground_truth_values,
            f=predict_values,
        )
